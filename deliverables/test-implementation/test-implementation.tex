\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{amsmath,amssymb}
\usepackage[colorlinks,linkcolor=blue]{hyperref} % use colored text in stead of ugly boxes
\usepackage[toc]{multitoc} % Nice two-column TOC

\usepackage{pgf}
\usepackage{tikz}
\usepackage{pictures/tikz-uml}

\title{Programming Life - Test and implementation plan }

\author{Group 5/E:\\
Felix Akkermans \\
Niels Doekemeijer \\
Thomas van Helden \\
Albert ten Napel \\
Jan Pieter Waagmeester}

\begin{document}
\maketitle

\vfill

\small{\tableofcontents}
\pagebreak

\section{Introduction}
In this report the different testing techniques we will use for this project will be explained. Because our solution has a clear division between server and client and because these will be developed in different programming environments, we will also need different testing strategies for the client and server. In chapter 2 a prioritization of the requirements can be found using the MoSCoW system. Chapter 3 will explain how we will test the server and client, and what strategies we will use. Lastly chapter 4 will cover the risk analysis, describing the risks for the successful implementation of the system.

\section{MoSCoW prioritization}
In this chapter we will specify our priorities of requirements using the MoSCoW model. This model divides requirements on how viable it is to implement certain features: Must-Haves are features that the application cannot do without. These are all necessary for the program to function properly. Should-Haves group the features that are high-priority, but are not critical for the system. Could-Haves are features that would be nice to be have, should the time allow it and Wont-Haves are features that will not be implemented (in this version of the program).

\subsection{Must Haves}
\begin{description}
\item[Available gates] The application must be able to present a list of available gates to the user. These gates can be used to model the circuit.
\item[Design circuit] The user must be able to design a circuit by specifying gates (using a drag-and-drop) and the relations between these gates.
\begin{itemize}
\item The application must be able to visualize a gate using a simplified image. This image should relate to the function of the gate. For example, for the AND gate, it is logical to use the AND symbol normally used in circuit design.
\item The user must be able to drag and drop gates from the list into the working area.
\item The user must be able freely to move the gate around in the working area, but gates snap to grid points on the working area.
\item The user must be able to draw relaties between the gates in the form of wires.
\item The user must be able to draw input and output wires for the circuit, to explicitly state which proteins will be used as input.
\end{itemize}
\item[Available proteins] The application must be able to present the user with an overview of available proteins to assign to signals (visualized by the wires).
\item[Protein specification] The user must be able to specify which protein is used for a certain signal.
\item[Export circuit] The application must to able to save a circuit.
\item[Import circuit] The application must be able to load an exported circuit.
\item[Input values specification] The user must be able to specify the input values used for the simulation of the circuit.
\item[Circuit validation] The user must to be able validate his circuit in the application and get feedback over where there are conflicts.
\item[Circuit simulation] The application must be able to simulate a valid circuit and present the output values to the user.
\end{description}

\subsection{Should Haves}
\begin{description}
\item[Re-use circuits] The application can import pre-defined circuits as extra gates. This is not a necessity, but would be a great addition to the program (and will ease building circuits). Among others, protein specification, importing and exporting will be more difficult to implement.
\end{description}

\subsection{Could Haves}
\begin{description}
\item[Determine proteins by specifying circuit, input and output values] It is possible to let an algorithm choose the best proteins for the signals in a circuit, given user specified input and output values. This feature should be a nice extra and will be implemented if time allows it.
\item[Local back-up] If, for whatever reason, a crash occurs (the connection drops, the server stops functioning, etc.), it would be nice to provide the user with a backup of his/her work. This feature has not much to do with the main goal of this application (creating and simulating a circuit), so that is why it is a could-have feature.
\item[Multi-client] The application must be able to handle multiple clients concurrently. This is not a point of attention, as modeling can easily be done one circuit at a time. Another issue is that implementing and properly testing this feature desires significant attention, that is why we will do it if we have enough time.
\end{description}

\subsection{Wont Haves}
\begin{description}
\item[Determine cirtcuit and proteins by specifying input and output values] It is possible to let an algorithm design a circuit based on merely given input and output signals. We deem designing such an algorithm takes up a lot of time and is very difficult to do properly given our limited timespan.
\item[Biological plausibility] It is very hard to create a program in which a user can model a biological circuit that will work in the real world as there are just too much (unpredictable) factors to take into account. With our limited knowledge of the subject, we will not try to pursue a biological plausible implementation.
\end{description}

\section{Implementation and tests}

\subsection{Order of implementation of features}
The concept of Scrum is to always have a working product. We will try to follow this concept. Because there is a distinction between the server and client side in our application, it should be easy for the group to work at the same time. The first steps of the building process would be to create a framework for sending/receiving messages between these two subsystems. \\

After that, steps can be made to gradually build up the application. This is our planning, in order of implementation:
\begin{itemize}
\item Server-Client communication (including definition of object formats);
\item List available proteins and gates;
\item Design circuit;
\item Specify proteins;
\item Validate circuit;
\item Import/Export circuits;
\item Specify input values;
\item Simulate circuit;
\item Re-use circuits;
\item Local back-up
\end{itemize}

\subsubsection{Iterations}
In our process of building the application, we will have Scrum iterations of two weeks each. This means that we only decide what to implement for the coming two weeks. After these two weeks, the application should have been improved (and still working!) and we will decide again for the coming two weeks. \\

We will have five iterations in total before delivering the final product. This is our planning:
\begin{enumerate}
\item Set up a basic back-end for the client and server side. It should be able to communicate the list of proteins and available gates.
\item The user should be able to model a circuit and specify the proteins for the signals.
\item Importing, exporting and specifying input values should work. Server side must be able to validate and simulate a circuit.
\item Client side must be able to show the simulation and be able to re-use circuits as new gates.
\item Margin for finishing touches and perhaps extra features such as local back-ups.
\end{enumerate}

\include{subsection-server-testing}
\include{subsection-client-testing}

\subsection{Testing Client-server integration}
Integration testing is done when the individual software modules are combined and need to be tested as a whole. One approach is to use unit tests which test the whole system. The server can be run on the same machine as the client, in this way the unit tests can test these two components.
After this validation testing needs to be done, the system needs to be validated if it conforms to the requirements. This will be done by letting a third party test the software. After the testing the participants will be interviewed.

\section{Risk analysis}
In this chapter we will discuss what we see as possible risks to our project. We will look at the difficulty of serveral implementation steps. After that, testing difficulties will be discussed. Third point of attention is external parties. Who do we need beside our own team to finish this project successfully and how does that invoke issues? Furthermore we will examine what we will do if the project stumbles upon unforeseen problems. Finally we will have a look at every personâ€™s schedule to estimate their work pressure.

\subsection{Difficulties while implementing}
During the implementation of the program we might encounter some difficulties. This is only normal, but still we need to analyze what could happen and how we will respond. Our development process will be test driven. This means we will first write tests for what our program should do and afterwards work out how our application will succeed in passing this test.
 
One of the problems we might be facing lies in the general structure of our program. We have a client and a server. They need to communicate. Communication is a well-known area for problems. To counter this problem we do intensive testing using mock-ups for both the server and the client to test each part first. After both parts have been tested, we will have integration tests to see how both sides work together in a real environment. 

Another problem during implementation Is the client itself, or rather the GUI presented in the client. The GUI has to work with dragging and dropping gates into place. We do have an idea how this should be implemented, but during the designing process we already stumbled upon some scenarioâ€™s where gates might be hard to connect. We want the GUI to remain clear and not filled with gates and wires connecting them, losing sight of what belongs where.

The third problem we might face is of course the server. Problems in this sector will probably occur during the saving of data. The server is responsible for storing data and retrieving it if requested. We realize that this might go wrong, and errors might occur if the data is not stored properly or is edited by some other program. 

Because we are working with a five man team, there is always a chance that some people might name things differently. One person might call a function getApplicationName, while another might call it getAppName. Miscommunications like these can cause a lot of redundant code and errors, especially if different persons keep changing classes. It is hard to keep an overview of which function has been used where, so removing a function might damage a totally different class. This problem can be easily countered with a good design and a proper ontology.

\subsection{Difficulties with testing}
As said before our development is test driven. This means that testing is extremely important and problems during testing should be countered early on in the development process. So what kind of problems do we expect during testing. 

Creating tests is rather difficult. You have your set of requirements, but you also need to test some of the boundaries of your application. You also need to think about how intensively you are going to test every aspect of your application. This is stated in the previous chapters of this document, but still it remains a challenge not to be underestimated.

If a test is constructed properly and it fails, the application has a bug somewhere. But how do we find this bug and how do we fix it. So bug-tracking is also very important. Even though Java has some really good tools to help find bugs, it remains time consuming and we need to take this into account.

\subsection{External parties}
Our project is not heavily dependent upon external parties. However, we do occasionally have to wait for feedback from instructors. We are sometimes fully reliant upon information given by instructors. However we do not expect a lot of difficulties with this.

\subsection{Unforeseen problems}
What happens if something unexpected happens? If we stumble upon a problem we did not foresee? We might have to add additional features to our application or we find a bug which we cannot easily fix. If problems like these occur we need to use our spare time to fix these problems. We have a strict planning of when everything is due, and in planning this we kept some spare time to deal with unexpected issues.

\subsection{Work stress of every team member}
The work stress of most members of our team is pretty high. Four out of five follow a lot of courses, which leads to more practical work than just this project. We need to take into account deadlines of other projects. The fifth member, during the 3rd semester, only does this course. However, he is a board member of a student association which takes a lot of time as well. We do take this into account but not as much, simply because it is not a constant pressure.

\end{document}
