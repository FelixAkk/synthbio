\subsection{Client Test plan}
Client testing can be separated from the development of the server by mocking different server-replies in simple text-files. These different test files contain replies the server might give to certain requests from te client and must be interpreted by the client code. They will be served as a static file from a webserver, so the only part we remove from the `normal equation' is the server \textit{deciding} what to reply.

Making these mockups costs time, but we think de decoupling of the development and testing of the client and the server is a valuable

\subsubsection{Unit testing}
In order to test various small parts of the system we'll use unit tests. Defining unit tests is a good way to test for expected functionality but also ensure stability in functionality while changes to other parts of te code are made. Since we'll use the JQuery-framework in our frontend code, its unit testing framework QUnit\footnote{QUnit: a powerfull, easy-to-use, JavaScript test suite. \url{http://docs.jquery.com/QUnit}} seems a logical choice. It can be used just like JUnit to define small unit tests before implemtation of certain functionality during Test Driven Development and to prevent regression of implemented features. Some examples of unit tests include:
\begin{enumerate}
	\item The circuit and the smaller parts of it will exist in JavaScript as objects. They'll have \verb|toJSON()|-methods which can be tested.
	\item The circuit parts parsing from from small JSON-snippets to JavaScript-objects can be tested.
\end{enumerate}

\subsubsection{Integration testing}
Some integration can be tested through the use of QUnit as well, but it might be usefull to use Crawljax\footnote{Home of Crawljax: \url{http://crawljax.com/}}, especially for some more complex interaction tests.

The core of our integration tests will consist of behaviour of several \text{unit}s, covered with unit tests, functioning together. Some examples include:
\begin{enumerate}
	\item Parsing the (mocked) JSON-input from the server to JavaScript objects and than back to JSON. Input and output should be equal.
	\item Loading a file from the server by using Crawljax to push buttons and checking the resulting JavaScript objects.
\end{enumerate}

\subsubsection{Acceptance testing}
User stories developed for each development run provide valuable information about acceptance tests to be executed. For each user story we'll create one or more acceptence tests, which may consist of unit and integration testing.

For some things not really measureable, like usability, we'll use additional manual tests, both performed by the members of the development team and volunteers around us.
